"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Personalizer = void 0;
const internal_1 = require("@sitecore-cloudsdk/core/internal");
const consts_1 = require("../consts");
const send_call_flows_request_1 = require("./send-call-flows-request");
class Personalizer {
    /**
     * The Personalizer Class runs a flow of interactive experiments.
     * @param browserId - The browser id of the user
     * @param guestId - The guestRef of the user
     */
    constructor(browserId, guestId) {
        this.browserId = browserId;
        this.guestId = guestId;
    }
    /**
     * A function to make a request to the Sitecore EP /callFlows API endpoint
     * @param personalizeData - The personalize input from the developer
     * @param settings - The setting that was set during initialization
     * @param opts - Optional object that contains options for timeout and UA
     * @returns - A promise that resolves with either the Sitecore EP response object or null
     */
    async getInteractiveExperienceData(personalizeData, settings, searchParams, opts) {
        this.validate(personalizeData);
        const sanitizedInput = this.sanitizeInput(personalizeData);
        if (searchParams.includes(consts_1.UTM_PREFIX) && !sanitizedInput.params?.utm) {
            sanitizedInput.params = sanitizedInput.params || {};
            sanitizedInput.params.utm = this.extractUrlParamsWithPrefix(searchParams, consts_1.UTM_PREFIX);
        }
        const mappedData = this.mapPersonalizeInputToEPData(sanitizedInput);
        if (!mappedData.email && !mappedData.identifiers)
            mappedData.browserId = this.browserId;
        return await (0, send_call_flows_request_1.sendCallFlowsRequest)(mappedData, settings, opts);
    }
    /**
     * A function that sanitizes the personalize input data
     * @returns - The sanitized object
     */
    sanitizeInput(personalizeData) {
        const sanitizedData = {
            channel: personalizeData.channel,
            currency: personalizeData.currency,
            friendlyId: personalizeData.friendlyId,
            language: personalizeData.language
        };
        if (personalizeData.identifier && personalizeData.identifier.id && personalizeData.identifier.id.trim().length > 0)
            sanitizedData.identifier = personalizeData.identifier;
        if (personalizeData.email && personalizeData.email.trim().length > 0)
            sanitizedData.email = personalizeData.email;
        if (personalizeData.params && Object.keys(personalizeData.params).length > 0)
            sanitizedData.params = personalizeData.params;
        if (personalizeData.geo && Object.keys(personalizeData.geo).length > 0)
            sanitizedData.params = { ...personalizeData.params, geo: { ...personalizeData.geo } };
        if (personalizeData.pageVariantIds?.length)
            sanitizedData.pageVariantIds = personalizeData.pageVariantIds;
        return sanitizedData;
    }
    /**
     * A function that maps the personalize input data with the EP
     * @returns - The EP object
     */
    mapPersonalizeInputToEPData(input) {
        const mappedData = {
            channel: input.channel,
            clientKey: '',
            currencyCode: input.currency,
            email: input.email,
            friendlyId: input.friendlyId,
            guestRef: this.guestId,
            identifiers: input.identifier,
            language: input.language ?? (0, internal_1.language)(),
            params: input.params,
            pointOfSale: '',
            variants: input.pageVariantIds
        };
        return mappedData;
    }
    /**
     * A validation method to throw error for the mandatory property for runtime users
     */
    validate({ friendlyId }) {
        if (!friendlyId || friendlyId.trim().length === 0)
            throw new Error(consts_1.ErrorMessages.MV_0004);
    }
    /**
     * Retrieves UTM parameters from the url query string e.g. `utm_test1=123&utm_test2=456`
     * @param urlParams - The url params passed
     * @param prefix - The prefix we want to extract from the params
     * @returns - an object containing the UTM parameters (if they exist) in the form: `utm: {test1: 123, test2: 456}`
     */
    extractUrlParamsWithPrefix(urlParams, prefix) {
        const urlSearchParams = new URLSearchParams(decodeURI(urlParams));
        const extractedParams = {};
        urlSearchParams.forEach((value, key) => {
            const paramKey = key.toLowerCase();
            if (paramKey.indexOf(prefix) === 0) {
                const paramName = paramKey.substring(prefix.length);
                extractedParams[paramName] = value;
            }
        });
        return extractedParams;
    }
}
exports.Personalizer = Personalizer;
